# Story 1.5.9.1: Refactor Bookmarks to Use Drizzle ORM

## Status
**Ready for Review** ✅

## Story
**As a** developer maintaining the codebase,  
**I want** to refactor the Bookmarks API routes from raw Supabase client to Drizzle ORM,  
**so that** we achieve consistency with the rest of the codebase, improved type safety, and better maintainability.

**Context:** Story 1.5.9 (Bookmarks View) was implemented using the raw Supabase client for bookmark operations. This was functionally correct and passed all QA gates (Quality Score: 98/100, 27/27 tests passing). However, during the Next.js production build, it became clear that the project has Drizzle ORM fully configured and other features (ProgressService, NotesService, ContentService) use Drizzle's service layer pattern. We should refactor bookmarks to follow the same architectural pattern for consistency and maintainability, as successfully demonstrated in Story 1.5.6.1 (Discussion Modal refactoring).

## Acceptance Criteria

1. All API routes in `/api/bookmarks/` use Drizzle ORM instead of raw Supabase client.
2. Schema definition for `bookmarks` table is added to the Drizzle schema (`src/lib/db/schema/bookmarks.ts`).
3. A `BookmarksService` is created following the same service layer pattern as `UserService`, `CommentService`, and other services.
4. All existing API contracts and response formats remain unchanged (zero breaking changes).
5. All bookmark operations (create, remove, list with joins) work identically to the existing implementation.
6. Type safety is improved with schema-driven types replacing manual TypeScript interfaces.
7. Unit tests are created for `BookmarksService` with mocked database operations.
8. All existing tests (27/27) continue to pass after refactoring.
9. Performance is maintained or improved compared to existing Supabase client implementation.
10. Code follows the established patterns from Story 1.4.1 (database layer migration) and Story 1.5.6.1 (comment refactoring).
11. Remove bookmarks table definition from `src/lib/database.ts` (should only contain Supabase client initialization).
12. Production build completes without TypeScript errors.

## Tasks / Subtasks

- [x] Task 1: Create Drizzle Schema for Bookmarks Table (AC: 2, 6, 11)
  - [x] Create `src/lib/db/schema/bookmarks.ts` file
  - [x] Add `bookmarks` table schema using `pgTable()` from `drizzle-orm/pg-core`
  - [x] Define TypeScript types: `Bookmark` and `InsertBookmark`
  - [x] Add relations to `users` and `concepts` tables
  - [x] Add UNIQUE constraint on (userId, conceptId)
  - [x] Add indexes for user_id and concept_id lookups
  - [x] Export types and table from schema
  
- [x] Task 2: Update Schema Index (AC: 2)
  - [x] Update `src/lib/db/schema/index.ts`
  - [x] Import and export bookmarks schema
  - [x] Add `bookmarks` and `bookmarksRelations` to schema object
  - [x] Add to `tableNames` constant
  
- [x] Task 3: Create BookmarksService Class (AC: 3, 6, 10)
  - [x] Create `src/lib/db/services/BookmarksService.ts` extending BaseService
  - [x] Implement `createBookmark(userId: string, conceptId: string)` method
  - [x] Implement `removeBookmark(bookmarkId: string, userId: string)` method
  - [x] Implement `getUserBookmarks(userId: string)` method with joins
  - [x] Implement `getBookmarkByUserAndConcept(userId: string, conceptId: string)` helper
  - [x] Add proper error handling with ServiceError classes
  - [x] Include connection cleanup in all database operations
  
- [x] Task 4: Migrate POST Bookmark API Route (AC: 1, 4, 5)
  - [x] Update `src/app/api/bookmarks/route.ts` POST handler
  - [x] Replace Supabase client calls with `BookmarksService.createBookmark()`
  - [x] Preserve existing validation (user authentication, concept_id)
  - [x] Maintain identical response format
  - [x] Handle duplicate bookmark attempts (upsert or return existing)
  
- [x] Task 5: Migrate DELETE Bookmark API Route (AC: 1, 4, 5)
  - [x] Update `src/app/api/bookmarks/[id]/route.ts` DELETE handler
  - [x] Replace Supabase client calls with `BookmarksService.removeBookmark()`
  - [x] Preserve ownership verification (bookmark belongs to user)
  - [x] Maintain identical response format
  - [x] Handle error scenarios identically
  
- [x] Task 6: Migrate GET Bookmarks List API Route (AC: 1, 4, 5, 9)
  - [x] Update `src/app/api/users/[id]/bookmarks/route.ts` GET handler
  - [x] Replace Supabase queries with `BookmarksService.getUserBookmarks()`
  - [x] Preserve joins with concepts, chapters, and notes tables
  - [x] Maintain sorting by bookmarked_at DESC
  - [x] Ensure response format matches TypeScript interface
  - [x] Handle empty bookmarks list correctly
  
- [x] Task 7: Clean Up Database.ts File (AC: 11)
  - [x] Remove bookmarks table definition from `src/lib/database.ts` (lines 248-270)
  - [x] Ensure file only contains Supabase client initialization
  - [x] Update any imports that referenced the old bookmarks type
  
- [x] Task 8: Create Unit Tests for BookmarksService (AC: 7)
  - [x] Create `__tests__/lib/db/services/BookmarksService.test.ts`
  - [x] Test createBookmark() with valid and invalid inputs
  - [x] Test removeBookmark() with ownership verification
  - [x] Test getUserBookmarks() with joins and sorting
  - [x] Test getBookmarkByUserAndConcept() helper
  - [x] Test error handling for database failures
  - [x] Test connection cleanup and resource management
  - [x] Mock database operations using Jest
  
- [x] Task 9: Verify Existing Tests Still Pass (AC: 8, 12)
  - [x] Run `__tests__/components/Dashboard/BookmarksView.test.tsx` (11 tests)
  - [x] Run `__tests__/components/Dashboard/BookmarkCard.test.tsx` (16 tests)
  - [x] Verify all 27 tests still pass
  - [x] Test bookmark button on ConceptViewer still works
  - [x] Verify production build completes without errors
  
- [x] Task 10: Update Documentation and Type Exports (AC: 6, 10)
  - [x] Export Bookmark and InsertBookmark types from schema
  - [x] Update API route imports to use Drizzle types
  - [x] Document migration in story Change Log
  - [x] Update technical debt section in Story 1.5.9

## Dev Notes

### Previous Story Context
- **Story 1.5.9** (Bookmarks View) completed: Implemented using raw Supabase client [Source: docs/stories/1.5.9.bookmarks-view.md]
- **Story 1.4.1** (Database Layer Migration) completed: Established Drizzle ORM patterns with BaseService [Source: docs/stories/1.4.1.database-layer-drizzle-orm-migration.md]
- **Story 1.5.6.1** (Discussion Refactoring) completed: Successfully migrated comments from Supabase to Drizzle [Source: docs/stories/1.5.6.1.refactor-discussion-drizzle-orm.md]

### Project Structure
**File Locations:**
```plaintext
apps/web/
├── src/
│   ├── lib/
│   │   ├── database.ts              # MODIFY: Remove bookmarks table definition
│   │   └── db/
│   │       ├── schema/
│   │       │   ├── bookmarks.ts     # CREATE: bookmarks schema
│   │       │   └── index.ts         # UPDATE: Export bookmarks schema
│   │       └── services/
│   │           ├── BaseService.ts   # EXISTING: Extend for BookmarksService
│   │           ├── UserService.ts   # REFERENCE: Pattern to follow
│   │           ├── CommentService.ts # REFERENCE: Pattern to follow
│   │           └── BookmarksService.ts # CREATE: New service
│   ├── app/
│   │   └── api/
│   │       ├── bookmarks/
│   │       │   ├── route.ts         # REFACTOR: POST handler
│   │       │   └── [id]/
│   │       │       └── route.ts     # REFACTOR: DELETE handler
│   │       └── users/
│   │           └── [id]/
│   │               └── bookmarks/
│   │                   └── route.ts  # REFACTOR: GET handler
└── __tests__/
    ├── lib/
    │   └── db/
    │       └── services/
    │           └── BookmarksService.test.ts  # CREATE: Unit tests
    └── components/
        └── Dashboard/
            ├── BookmarksView.test.tsx        # VERIFY: Still passes
            └── BookmarkCard.test.tsx         # VERIFY: Still passes
```

### Technology Stack
- **ORM Framework:** Drizzle ORM (installed in Story 1.4.1)
- **Database Client:** pg (PostgreSQL driver)
- **TypeScript:** ~5.x with strict mode enabled
- **Testing:** Jest 30.x for unit tests

### Existing Database Schema from Story 1.5.9
[Source: docs/stories/1.5.9.bookmarks-view.md]

**bookmarks Table:**
```sql
CREATE TABLE bookmarks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  concept_id UUID NOT NULL REFERENCES concepts(id) ON DELETE CASCADE,
  bookmarked_at TIMESTAMP DEFAULT now(),
  UNIQUE (user_id, concept_id)
);

CREATE INDEX idx_bookmarks_user ON bookmarks(user_id);
CREATE INDEX idx_bookmarks_concept ON bookmarks(concept_id);
```

### Drizzle Schema Pattern
[Source: Story 1.4.1, Story 1.5.6.1]

**Example Schema Definition:**
```typescript
// src/lib/db/schema/bookmarks.ts
import { pgTable, uuid, timestamp, unique, index } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
import { users } from './users';
import { concepts } from './concepts';

// Table schema
export const bookmarks = pgTable('bookmarks', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  conceptId: uuid('concept_id').notNull().references(() => concepts.id, { onDelete: 'cascade' }),
  bookmarkedAt: timestamp('bookmarked_at').defaultNow().notNull(),
}, (table) => ({
  userIdx: index('idx_bookmarks_user').on(table.userId),
  conceptIdx: index('idx_bookmarks_concept').on(table.conceptId),
  uniqueUserConcept: unique('bookmarks_user_concept_unique').on(table.userId, table.conceptId),
}));

// Relations
export const bookmarksRelations = relations(bookmarks, ({ one }) => ({
  user: one(users, {
    fields: [bookmarks.userId],
    references: [users.id],
  }),
  concept: one(concepts, {
    fields: [bookmarks.conceptId],
    references: [concepts.id],
  }),
}));

// Types
export type Bookmark = typeof bookmarks.$inferSelect;
export type InsertBookmark = typeof bookmarks.$inferInsert;
```

### Service Layer Pattern
[Source: Story 1.4.1, Story 1.5.6.1]

**Example Service Implementation:**
```typescript
// src/lib/db/services/BookmarksService.ts
import { eq, and, desc } from 'drizzle-orm';
import { BaseService } from './BaseService';
import { bookmarks } from '../schema/bookmarks';
import { concepts } from '../schema/concepts';
import { chapters } from '../schema/chapters';
import { notes } from '../schema/notes';
import type { Bookmark, InsertBookmark } from '../schema/bookmarks';

export class BookmarksService extends BaseService {
  /**
   * Create a new bookmark for a user
   */
  async createBookmark(userId: string, conceptId: string): Promise<Bookmark> {
    const db = await this.getDb();
    try {
      const [bookmark] = await db
        .insert(bookmarks)
        .values({ userId, conceptId })
        .onConflictDoNothing() // Handle duplicate gracefully
        .returning();
      
      if (!bookmark) {
        // Bookmark already exists, fetch and return it
        return await this.getBookmarkByUserAndConcept(userId, conceptId);
      }
      
      return bookmark;
    } finally {
      await this.closeConnection();
    }
  }

  /**
   * Remove a bookmark
   */
  async removeBookmark(bookmarkId: string, userId: string): Promise<void> {
    const db = await this.getDb();
    try {
      const result = await db
        .delete(bookmarks)
        .where(and(
          eq(bookmarks.id, bookmarkId),
          eq(bookmarks.userId, userId)
        ));
      
      if (result.rowCount === 0) {
        throw new Error('Bookmark not found or unauthorized');
      }
    } finally {
      await this.closeConnection();
    }
  }

  /**
   * Get all bookmarks for a user with concept details
   */
  async getUserBookmarks(userId: string) {
    const db = await this.getDb();
    try {
      return await db
        .select({
          id: bookmarks.id,
          user_id: bookmarks.userId,
          concept_id: bookmarks.conceptId,
          concept_title: concepts.title,
          concept_slug: concepts.slug,
          chapter_number: chapters.chapterNumber,
          chapter_title: chapters.title,
          note_preview: notes.content, // Will be truncated in API
          bookmarked_at: bookmarks.bookmarkedAt,
        })
        .from(bookmarks)
        .innerJoin(concepts, eq(bookmarks.conceptId, concepts.id))
        .innerJoin(chapters, eq(concepts.chapterId, chapters.id))
        .leftJoin(notes, and(
          eq(notes.conceptId, concepts.id),
          eq(notes.userId, bookmarks.userId)
        ))
        .where(eq(bookmarks.userId, userId))
        .orderBy(desc(bookmarks.bookmarkedAt));
    } finally {
      await this.closeConnection();
    }
  }

  /**
   * Get bookmark by user and concept (helper)
   */
  async getBookmarkByUserAndConcept(userId: string, conceptId: string): Promise<Bookmark | null> {
    const db = await this.getDb();
    try {
      const [bookmark] = await db
        .select()
        .from(bookmarks)
        .where(and(
          eq(bookmarks.userId, userId),
          eq(bookmarks.conceptId, conceptId)
        ))
        .limit(1);
      
      return bookmark || null;
    } finally {
      await this.closeConnection();
    }
  }
}
```

### API Response Formats (Must Be Preserved)
[Source: docs/stories/1.5.9.bookmarks-view.md]

**POST /api/bookmarks Response:**
```typescript
{
  success: boolean;
  bookmark: {
    id: string;
    concept_id: string;
    bookmarked_at: string; // ISO 8601 timestamp
  }
}
```

**DELETE /api/bookmarks/{id} Response:**
```typescript
{
  success: boolean;
}
```

**GET /api/users/{id}/bookmarks Response:**
```typescript
{
  bookmarks: [
    {
      id: string;
      user_id: string;
      concept_id: string;
      concept_title: string;
      concept_slug: string;
      chapter_number: number;
      chapter_title: string;
      note_preview: string;  // First 100 chars of note
      bookmarked_at: timestamp;
    }
  ]
}
```

### Testing Strategy

**Unit Tests for BookmarksService:**
```typescript
// __tests__/lib/db/services/BookmarksService.test.ts
import { BookmarksService } from '@/lib/db/services/BookmarksService';

describe('BookmarksService', () => {
  let service: BookmarksService;

  beforeEach(() => {
    service = new BookmarksService();
  });

  describe('createBookmark', () => {
    it('creates a new bookmark successfully', async () => {
      const bookmark = await service.createBookmark('user-1', 'concept-1');
      expect(bookmark).toHaveProperty('id');
      expect(bookmark.userId).toBe('user-1');
      expect(bookmark.conceptId).toBe('concept-1');
    });

    it('handles duplicate bookmark gracefully', async () => {
      // Mock duplicate scenario
      // Should return existing bookmark instead of throwing error
    });
  });

  describe('removeBookmark', () => {
    it('removes bookmark successfully', async () => {
      await expect(
        service.removeBookmark('bookmark-1', 'user-1')
      ).resolves.not.toThrow();
    });

    it('throws error for unauthorized removal', async () => {
      await expect(
        service.removeBookmark('bookmark-1', 'wrong-user')
      ).rejects.toThrow('Bookmark not found or unauthorized');
    });
  });

  describe('getUserBookmarks', () => {
    it('returns bookmarks with joined data', async () => {
      const bookmarks = await service.getUserBookmarks('user-1');
      expect(bookmarks).toBeInstanceOf(Array);
      if (bookmarks.length > 0) {
        expect(bookmarks[0]).toHaveProperty('concept_title');
        expect(bookmarks[0]).toHaveProperty('chapter_number');
      }
    });

    it('returns empty array for user with no bookmarks', async () => {
      const bookmarks = await service.getUserBookmarks('new-user');
      expect(bookmarks).toEqual([]);
    });
  });
});
```

### Success Criteria Summary

✅ **Zero Breaking Changes:**
- All API endpoints maintain exact same contracts
- Frontend components work without modifications
- All 27 existing tests pass

✅ **Architectural Consistency:**
- Follows established service layer pattern
- Uses Drizzle ORM like other features
- Proper type safety with schema-driven types

✅ **Quality Maintained:**
- Production build completes successfully
- No TypeScript errors
- Performance equal or better

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-14 | 1.0 | Initial technical debt story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
Claude 4.5 Sonnet

### Debug Log References
None required - straightforward refactoring with no issues

### Completion Notes List
- Successfully migrated all bookmark operations from raw Supabase client to Drizzle ORM
- Created comprehensive BookmarksService with 16 passing unit tests
- All 27 existing tests continue to pass (11 BookmarksView + 16 BookmarkCard)
- Zero breaking changes - all API contracts maintained
- Removed bookmarks table definition from database.ts as planned
- Schema properly integrated with existing Drizzle setup

### File List
**Created:**
- `apps/web/src/lib/db/schema/bookmarks.ts` - Drizzle schema for bookmarks table
- `apps/web/src/lib/db/services/BookmarksService.ts` - Service layer for bookmark operations
- `apps/web/__tests__/lib/db/services/BookmarksService.test.ts` - Unit tests (16 tests)

**Modified:**
- `apps/web/src/lib/db/schema/index.ts` - Added bookmarks exports and schema integration
- `apps/web/src/lib/db/services/index.ts` - Added BookmarksService export
- `apps/web/src/app/api/bookmarks/route.ts` - Migrated POST handler to use BookmarksService
- `apps/web/src/app/api/bookmarks/[id]/route.ts` - Migrated DELETE handler to use BookmarksService
- `apps/web/src/app/api/users/[id]/bookmarks/route.ts` - Migrated GET handler to use BookmarksService
- `apps/web/src/lib/database.ts` - Removed bookmarks table definition (lines 248-270)
